# PrefabPalette: Developers

---
## See Also
* [ReadMe](./README.md)
* [ContributionsGuide](./ContributionsGuide.md)
---
## Overview

This document outlines the architecture of the project.

## Editor Folder Structure
* **Generated:** For all objects generated by the tool.

* **Resources:** For all shared resources like icons and images.

* **Scripts:** Contains all the scripts for the tool.  
  * **Main Windows:** For editor windows opened via the Unity Editor’s `Window` toolbar option.

  * **Overlays:** Scripts for the scene view overlay panel.

  * **Placement Modes:** This is where the logic and settings for placement modes should be stored. Refer to the *Creating New Modes* section for more detailed guidance.

  * **Prefab Collections:** For logic related to creating and managing prefab collections.

  * **Utilities:** For helper and core utility scripts.

## Modes

The modes system is a finite state machine (FSM), making it straightforward to define and transition between new modes.

### Class Diagram
```mermaid
  classDiagram
      direction LR

      %% ==== Core Unity Type ====
      class ScriptableObject {
          <<Unity base>>
      }

      %% ==== Interfaces and Base Classes ====
      class IPlacementMode {
          <<interface>>
          +OnEnter(ToolContext)
          +OnActive(ToolContext)
          +OnExit(ToolContext)
          +string[] ControlsHelpBox
          +SettingsOverlayGUI(ToolContext)
      }

      class PlacementModeSettings {
          <<abstract>>
          // Manages saving on disable
      }

      %% ==== User-defined Mode and Settings ====
      class ExampleModeSettings {
          // Custom fields...
      }

      class ExampleMode {
          -ExampleModeSettings modeSettings
          +ExampleMode(PlacementModeSettings)
          +OnEnter(ToolContext)
          +OnActive(ToolContext)
          +OnExit(ToolContext)
          +string[] ControlsHelpBox
          +SettingsOverlayGUI(ToolContext)
      }

      class PlacementModeManager {
          +InitialiseToolbarButtons()
          +InitialisePlacementModes()
                    +Enum ModeName
          +Dictionary modes
      }

      %% ==== Inheritance / Implementation Relationships ====
      IPlacementMode <|.. ExampleMode : implements
      PlacementModeSettings <|-- ExampleModeSettings
      ScriptableObject <|-- PlacementModeSettings

      %% ==== Usage Relationships ====
      ExampleMode --> ExampleModeSettings : uses
      PlacementModeManager --> IPlacementMode : manages
```

### Creating New Mode
This section explains how to define and integrate new modes into the system.

1\. **Create a new C\# script for the modes logic.**  
In the project window, create an empty C\# script in the *`PrefabPalette > Editor > Scripts > PlacementModes > Modes`* folder.

2\. **Inherit from IPlacementMode**  
Open the script and ensure the class is within the `PrefabPalette` namespace.

The class should iInherit from `IPlacementMode` and implement the following contract:

| **Lifecycle Methods** | |
| :---- | :---- |
| **public void OnEnter(ToolContext)** | Called when the mode is first selected from the overlay. |
| **public void OnActive(ToolContext)** | Called while the mode is active, similar to Unity’s update method. |
| **public void OnExit(ToolContext)** | Called when transitioning away from this mode to a new one. |

|**UI**||
| :---- | :---- |
|  **public string[] ControlsHelpBox { get; }** | Populates the *Controls Dropdown* on the overlay, providing an overview of the mode's controls. <br>The content is rendered as a 2-column table. <br>For example: <br>`public string[] ControlsHelpBox => new string[] { “LMB”, “Place Point”, “Enter”, “Confirm Line”, "Escape", "Cancel Drawing Line" };` <br>Renders as:<br>![Alt text for the image](imgs/ControlsDropdown.png)|
| **public void SettingsOverlayGUI(ToolContext)** | Renders mode specific ui content below the *Controls Dropdown* on the overlay. |

3\. **Create new mode settings object**

* In the project window, navigate to *`PrefabPalette > Editor > Scripts > PlacementModes > Settings`* folder and create an empty C\# script called (NAME)ModeSettings. Replace (NAME) with the same name given to the mode script.

* Ensure the class is inside the `PrefabPalette` namespace, and inherits from `PlacementModeSettings`.

* In the mode script, create a new private instance field for its settings object.  
  Then, create a constructor that takes `PlacementModeSettings` as a parameter, and cast it the mode specific settings type.


4\. **Add new mode to Placement Mode Manager**
To integrate the new mode into the system, the mode needs to be registered with the `PlacementModeManager`, where the settings object is is assigned at the same time.   

* Navigate to *`PrefabPalette > Editor > Scripts > PlacementModes > PlacementModeManager.cs`* and open the script.

* Add the modes name to the *`ModeName`* enum.
      
      ...

      public enum ModeName
      {
        Single,
        Line,
        ExampleMode
      }

      ...

* In the `InitialiseToolbarButtons` method, Add the new modes icon to the array. 

      ...

      private static void InitialiseToolbarButtons()
      {
        // Add buttons to the toolbar here:
        // NOTE: ModeName enum and toolbarButtons must be in the same order.
        toolbarButtons = new GUIContent[]
        {
          new GUIContent(EditorGUIUtility.IconContent("d_MoveTool").image, "Single Mode"),
          new GUIContent(Resources.Load<Texture2D>("Imgs/LineIcon"), "Line Mode"),
          new GUIContent(Resources.Load<Texture2D>("Imgs/NewModeExampleIcon", "Example Mode)) // New Mode Icon
        };
      }

      ...

* Register the new mode in the `modes` dictionary and create a new instance using the `CreateModeInstance` method.

        ...

        private static void InitialisePlacementModes()
        {
          // Hook up the modes class with the mode enum:
          modes = new Dictionary<ModeName, IPlacementMode>()
          {
            { ModeName.Line, CreateModeInstance<LineModeSettings, LineDrawMode>("LineModeSettings.asset") },
            { ModeName.Single, CreateModeInstance<SingleModeSettings, SinglePrefabMode>("SingleModeSettings.asset") },
            { ModeName.ExampleMode, CreateModeInstance<ExampleModeSettings, ExampleMode>("ExampleModeSettings.asset") }, // New Mode Instance
          };
        }

        ...

### Script Example Templates
#### Mode
    namespace PrefabPalette
    {
      public class ExampleMode : IPlacementMode
      {
        // Reference to the mode's settings.
        ExampleModeSettings modeSettings;

        /// <summary>
        /// Initializes the placement mode with its settings.
        /// </summary>
        public ExampleMode(PlacementModeSettings modeSettings)
        {
          // Cast PlacementModeSettings to ExampleModeSettings.
          this.modeSettings = (ExampleModeSettings)modeSettings;
        }

        /// <summary>
        /// Defines the control instructions displayed to the user.
        /// </summary>
        public string[] ControlsHelpBox => new string[] { };

        /// <summary>
        /// Called continuously while the mode is active and the Scene View updates.
        /// Use for drawing gizmos, handles, and handling interactive events.
        /// </summary>
        public void OnActive(ToolContext context)
        {
          // Implement interactive logic and Scene View drawing here...
        }

        /// <summary>
        /// Called once when the mode is initially activated.
        /// Use for setup operations.
        /// </summary>
        public void OnEnter(ToolContext context)
        {
          // Perform setup tasks...
        }

        /// <summary>
        /// Called once when the mode is deactivated or switched away from.
        /// Use for cleanup operations.
        /// </summary>
        public void OnExit(ToolContext context)
        {
          // Perform cleanup tasks...
        }

        /// <summary>
        /// Renders custom GUI for mode-specific settings in the overlay panel.
        /// </summary>
        public void SettingsOverlayGUI(ToolContext context)
        {
          // Draw mode settings UI elements...
        }
      }
    }

#### Mode Settings
    namespace PrefabPalette
    {
        public class ExampleModeSettings : PlacementModeSettings
        {
          // Mode specific settings...
        }
    }

### Troubleshooting

* **Invalid Operation Exception**
Ensure the modes constructor accepts a single `PlacementModeSetting` as a parameter and it is cast to the expected type.

---

## Prefab Collections System
### Collection Asset
The collection assets are scriptable objects stored in the `Generated/Collections` folder after creation. Scripts can access the current collection asset via the `Settings.CurrentPrefabCollection` property of the `ToolContext` class, where the collections asset is either read from the folder, or created if it doesn't already exist. Collections are deleted from the folder if they are removed from the `PrefabCollectionList`. 

### Enum Generation
The contents of the `Generated/Collections` folder is represented by the `CollectionsName` enum. An enum is used instead of strings to improve the user experience: It enables dropdowns in the editor for selecting collections, prevents manual manual typing errors and ensures only valid options are available. 

Since C# enums are immutable, it must be regenerated whenever the list of collections changes. This is handled by `PrefabCollectionList.GenerateEnum()`, which writes a `CollectionName.cs` enum file to the `Editor/Generated` folder. 

⚠️ Note: Unity recompile's scripts after the enum is generated.

### Collection Manager Window
New collections can be created directly from the collections manager window, however, this means the collection must be populated using the `PrefabCollectionInspector` window.

```mermaid
%% Mermaid: Left-to-right layout
classDiagram
    direction LR

    %% === ScriptableObjects ===
    class PrefabCollectionList {
      <<Scriptable Object>>
      +List~string~ collectionNames
      +static PrefabCollectionList Instance
      +void SyncListWithEnum()
      +void GenerateEnum()
    }

    class PrefabCollection {
      <<ScriptableObject>>
      -string nameAsString
      +List~GameObject~ prefabList
      +CollectionName Name
      +static PrefabCollection CreateNewCollection(CollectionName)
      +static List~PrefabCollection~ GetAllCollectionsInFolder
      +static PrefabCollection GetCollectionByName(CollectionName)
    }

    %% === Enums ===
    class CollectionName {
      <<enumeration>>
      +None
      +[other auto-generated values]
    }

    %% === EditorWindows ===
    class CollectionsManagerWindow {
      <<EditorWindow>>
      +static void OpenWindow()
    }
    class PrefabCollectionInspector {
      +static void OpenWindow(PrefabCollection)
      <<EditorWindow>>
    }

    class CollectionsListInspector {
      +static void OpenWindow()
      -void CleanupCollectionsFolder(...)
      <<EditorWindow>>
    }

    %% === Relationships ===
    CollectionsManagerWindow --> CollectionsListInspector : opens 
    CollectionsManagerWindow --> PrefabCollectionInspector : opens
    PrefabCollectionList --> CollectionName : generates enum
    PrefabCollectionInspector --> PrefabCollection : edits
    CollectionsListInspector --> PrefabCollectionList : edits
```

### Create Collection From Folder
A new `Prefab Collection` can be created with a right-click menu item in the project window. A dialog window in the editor lets the user enter a unique name for the new collection, which triggers the enum file to be rewritten, followed by the editor recompiling scripts. `EditorPrefs` is used to store the prefab paths during recompilation, where they are recovered during creation of the prefab collection asset.

⚠️ Note: Unity recompiles scripts after the enum is regenerated, triggering a domain reload. This is why state is persisted using EditorPrefs.

#### Sequence
```mermaid
sequenceDiagram
    participant User
    participant UnityEditor
    participant CreateCollectionFromFolder
    participant NameCollectionDialog
    participant EditorPrefs
    participant PrefabCollectionList
    participant PrefabCollection
    participant CollectionName

    Note over User: User selects prefabs or folder in Project window

    User->>UnityEditor: Right-click → "Create Prefab Collection"
    UnityEditor->>CreateCollectionFromFolder: MenuItem "Create()"

    CreateCollectionFromFolder->>CreateCollectionFromFolder: Collect prefab paths
    CreateCollectionFromFolder->>EditorPrefs: Store prefab list as JSON ("PendingPrefabList")
    CreateCollectionFromFolder->>NameCollectionDialog: Show() dialog for collection name

    Note over NameCollectionDialog: User enters collection name

    NameCollectionDialog-->>CreateCollectionFromFolder: Return name via callback
    CreateCollectionFromFolder->>EditorPrefs: Store name ("PendingPrefabCollectionName")

    CreateCollectionFromFolder->>PrefabCollectionList: Add name to collectionNames
    CreateCollectionFromFolder->>PrefabCollectionList: Call GenerateEnum()
    PrefabCollectionList->>CollectionName: Write enum file to Editor/Generated

    Note over UnityEditor: Domain reload (due to enum regeneration)

    Note over CreateCollectionFromFolder: [InitializeOnLoad] triggers after reload

    UnityEditor->>CreateCollectionFromFolder: Static constructor → delayCall

    CreateCollectionFromFolder->>EditorPrefs: Read collection name + prefab list
    CreateCollectionFromFolder->>PrefabCollection: Create new collection
    CreateCollectionFromFolder->>PrefabCollection: Populate with prefabs
    CreateCollectionFromFolder->>EditorPrefs: Clear keys
    CreateCollectionFromFolder->>UnityEditor: Show success dialog
```

#### Class Diagram
```mermaid
%% Mermaid: Left-to-right layout
classDiagram
    direction LR

    class EditorPrefs {
    <<Unity API>>
    +static void SetString(string, string)
    +static string GetString(string)
    +static void DeleteKey(string)
    +static bool HasKey(string)
    }

    %% === ScriptableObjects ===
    class PrefabCollectionList {
        <<Scriptable Object>>
        +List~string~ collectionNames
        +static PrefabCollectionList Instance
        +void SyncListWithEnum()
        +void GenerateEnum()
    }

    class PrefabCollection {
        <<ScriptableObject>>
        -string nameAsString
        +List~GameObject~ prefabList
        +CollectionName Name
        +static PrefabCollection CreateNewCollection(CollectionName)
        +static List~PrefabCollection~ GetAllCollectionsInFolder
        +static PrefabCollection GetCollectionByName(CollectionName)
    }

    %% === Enums ===
    class CollectionName {
        <<enumeration>>
        +None
        +[other auto-generated values]
    }

    %% === EditorWindows ===  
    class NameCollectionDialog {
        +static void Show(Action~string~)
        <<EditorWindow>>
    }

    %% === Static Utility ===
    class CreateCollectionFromFolder {
        <<static>>
        +static void Create()
        +static List~string~ GetPrefabPathsFromFolder(string)
        +static bool ValidateSelected()
    }

    %% === Relationships ===
    PrefabCollectionList --> CollectionName : generates enum
    CreateCollectionFromFolder --> NameCollectionDialog : shows window
    CreateCollectionFromFolder <-- NameCollectionDialog : returns user defined collection name
    CreateCollectionFromFolder --> PrefabCollection : creates and populates asset
    CreateCollectionFromFolder --> PrefabCollectionList : adds collection name
        CreateCollectionFromFolder --> EditorPrefs : uses for persistence
```

---

## Help and Support

If you need any help or have any questions, feel free to open a new issue on the repos issues page or send an email to reach@frayedfunction.com

---
